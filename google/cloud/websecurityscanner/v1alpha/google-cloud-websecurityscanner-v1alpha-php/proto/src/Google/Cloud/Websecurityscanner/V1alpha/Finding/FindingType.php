<?php
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: google/cloud/websecurityscanner/v1alpha/finding.proto

namespace Google\Cloud\Websecurityscanner\V1alpha\Finding;

use UnexpectedValueException;

/**
 * Types of Findings.
 *
 * Protobuf type <code>google.cloud.websecurityscanner.v1alpha.Finding.FindingType</code>
 */
class FindingType
{
    /**
     * The invalid finding type.
     *
     * Generated from protobuf enum <code>FINDING_TYPE_UNSPECIFIED = 0;</code>
     */
    const FINDING_TYPE_UNSPECIFIED = 0;
    /**
     * A page that was served over HTTPS also resources over HTTP. A
     * man-in-the-middle attacker could tamper with the HTTP resource and gain
     * full access to the website that loads the resource or to monitor the
     * actions taken by the user.
     *
     * Generated from protobuf enum <code>MIXED_CONTENT = 1;</code>
     */
    const MIXED_CONTENT = 1;
    /**
     * The version of an included library is known to contain a security issue.
     * The scanner checks the version of library in use against a known list of
     * vulnerable libraries. False positives are possible if the version
     * detection fails or if the library has been manually patched.
     *
     * Generated from protobuf enum <code>OUTDATED_LIBRARY = 2;</code>
     */
    const OUTDATED_LIBRARY = 2;
    /**
     * This type of vulnerability occurs when the value of a request parameter
     * is reflected at the beginning of the response, for example, in requests
     * using JSONP. Under certain circumstances, an attacker may be able to
     * supply an alphanumeric-only Flash file in the vulnerable parameter
     * causing the browser to execute the Flash file as if it originated on the
     * vulnerable server.
     *
     * Generated from protobuf enum <code>ROSETTA_FLASH = 5;</code>
     */
    const ROSETTA_FLASH = 5;
    /**
     * A cross-site scripting (XSS) bug is found via JavaScript callback. For
     * detailed explanations on XSS, see
     * https://www.google.com/about/appsecurity/learning/xss/.
     *
     * Generated from protobuf enum <code>XSS_CALLBACK = 3;</code>
     */
    const XSS_CALLBACK = 3;
    /**
     * A potential cross-site scripting (XSS) bug due to JavaScript breakage.
     * In some circumstances, the application under test might modify the test
     * string before it is parsed by the browser. When the browser attempts to
     * runs this modified test string, it will likely break and throw a
     * JavaScript execution error, thus an injection issue is occurring.
     * However, it may not be exploitable. Manual verification is needed to see
     * if the test string modifications can be evaded and confirm that the issue
     * is in fact an XSS vulnerability. For detailed explanations on XSS, see
     * https://www.google.com/about/appsecurity/learning/xss/.
     *
     * Generated from protobuf enum <code>XSS_ERROR = 4;</code>
     */
    const XSS_ERROR = 4;
    /**
     * An application appears to be transmitting a password field in clear text.
     * An attacker can eavesdrop network traffic and sniff the password field.
     *
     * Generated from protobuf enum <code>CLEAR_TEXT_PASSWORD = 6;</code>
     */
    const CLEAR_TEXT_PASSWORD = 6;
    /**
     * An application returns sensitive content with an invalid content type,
     * or without an 'X-Content-Type-Options: nosniff' header.
     *
     * Generated from protobuf enum <code>INVALID_CONTENT_TYPE = 7;</code>
     */
    const INVALID_CONTENT_TYPE = 7;
    /**
     * A cross-site scripting (XSS) vulnerability in AngularJS module that
     * occurs when a user-provided string is interpolated by Angular.
     *
     * Generated from protobuf enum <code>XSS_ANGULAR_CALLBACK = 8;</code>
     */
    const XSS_ANGULAR_CALLBACK = 8;
    /**
     * A malformed or invalid valued header.
     *
     * Generated from protobuf enum <code>INVALID_HEADER = 9;</code>
     */
    const INVALID_HEADER = 9;
    /**
     * Misspelled security header name.
     *
     * Generated from protobuf enum <code>MISSPELLED_SECURITY_HEADER_NAME = 10;</code>
     */
    const MISSPELLED_SECURITY_HEADER_NAME = 10;
    /**
     * Mismatching values in a duplicate security header.
     *
     * Generated from protobuf enum <code>MISMATCHING_SECURITY_HEADER_VALUES = 11;</code>
     */
    const MISMATCHING_SECURITY_HEADER_VALUES = 11;

    private static $valueToName = [
        self::FINDING_TYPE_UNSPECIFIED => 'FINDING_TYPE_UNSPECIFIED',
        self::MIXED_CONTENT => 'MIXED_CONTENT',
        self::OUTDATED_LIBRARY => 'OUTDATED_LIBRARY',
        self::ROSETTA_FLASH => 'ROSETTA_FLASH',
        self::XSS_CALLBACK => 'XSS_CALLBACK',
        self::XSS_ERROR => 'XSS_ERROR',
        self::CLEAR_TEXT_PASSWORD => 'CLEAR_TEXT_PASSWORD',
        self::INVALID_CONTENT_TYPE => 'INVALID_CONTENT_TYPE',
        self::XSS_ANGULAR_CALLBACK => 'XSS_ANGULAR_CALLBACK',
        self::INVALID_HEADER => 'INVALID_HEADER',
        self::MISSPELLED_SECURITY_HEADER_NAME => 'MISSPELLED_SECURITY_HEADER_NAME',
        self::MISMATCHING_SECURITY_HEADER_VALUES => 'MISMATCHING_SECURITY_HEADER_VALUES',
    ];

    public static function name($value)
    {
        if (!isset(self::$valueToName[$value])) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no name defined for value %s', __CLASS__, $value));
        }
        return self::$valueToName[$value];
    }


    public static function value($name)
    {
        $const = __CLASS__ . '::' . strtoupper($name);
        if (!defined($const)) {
            throw new UnexpectedValueException(sprintf(
                    'Enum %s has no value defined for name %s', __CLASS__, $name));
        }
        return constant($const);
    }
}

// Adding a class alias for backwards compatibility with the previous class name.
class_alias(FindingType::class, \Google\Cloud\Websecurityscanner\V1alpha\Finding_FindingType::class);

